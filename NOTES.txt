
1. Make a universal binary of phyml for mac. Currently the phyml version fails on ppc macs.
2. Compile windows and linux versions of Phyml too
3. Start gathering real datasets from e.g. recent issues of MBE, MPE, and SystBiol
4. Write a manual (keep it short! include a quickstart!).
4a.Put some references to phyml everywhere, including in the help text
5. Implement greedy algorithm, and branch and bound
6. Work out what to do when model results are identical?


Output Formats:

Per Subset

Model		lnL		AIC
JC			-300	150
JC+I		-295	200
JC+I+G		-200	250
...			...		...

these should go in a separate folder like subset_output
the models should also be ranked by AIC score

Per PartitionFinder run

Best Scheme:
Scheme Name
Scheme description
Scheme lnL
Scheme AIC

Best models for subsets in best scheme:
Subset_description		Best_model		Alignment_file
1-200\3 2-200\3			HKY+I+G			/subset_output/part1_part2.phy
...						...				...	


and, in another file, we have output for all of the schemes. There should be an option to produce this
All Schemes summary (ranked by AIC)
Scheme_AIC Scheme_lnL	Scheme_parameters	Scheme_lnL Scheme_description

# How to calculate the AIC for schemes (from ROB)

I've written a little phyml demo in our shared dropbox. Read the Explanation
file and hopefully it makes sense. Turns out there's a (hopefully minor) bug in
the new thing he wrote for us, I'm going to play around with it tonight and see
if I can figure it out. If not, I'll get in touch with him tomorrow.

For the subsets -> Schemes stuff:

Each subset should have a list of models, and the lnL of each model (this is
calculated with the new, buggy, bit of PhyML), and the number of parameters in
each model.

For each model in this list, we can then calculate the AIC as follows: AIC=2(k-lnL). 

Where k is the number of parameters in the model. I will write down a list of
models and p's soon, it'll just be a simple lookup.

This AIC allows us to pick the 'best' model for each subset. 

To calculate the AIC for a scheme, we do this: AIC=2(k-lnL) but now, lnL is the
sum of the  lnL's of all the subsets in that scheme, and k is the sum of all
the k's of the subsets in that scheme, PLUS (2n-3), where N is the number of
sequences in the dataset (2n-3 is the number of branchlengths), PLUS the number
of subsets in the scheme minus 1.

# TODO:

* Move fasta into a sequence.py file. Have a sequence class. It will know how to
get columns out and stuff



# DONE:

* Maybe should have an implicit universal configuration. Just keep it in
configuration? Stop trying to be so object-oriented?

* Get rid of partition sets. Just add to a list. When the first scheme is
  created we make it and lock it.


